<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
<title>Using as module &#8212; Python Markdown</title>
<link rel=stylesheet href=style.css>
</head>
<body>
<div id="nav">
<p><a href="/">Index</a></p>
<div class="toc">
<ul>
<li><a href="#using-markdown-as-a-python-library">Using Markdown as a Python Library</a><ul>
<li><a href="#the-basics">The Basics</a></li>
<li><a href="#the-details">The Details</a><ul>
<li><a href="#markdownmarkdowntext-kwargs">markdown.markdown(text [, **kwargs])</a></li>
<li><a href="#markdownmarkdownfromfilekwargs">markdown.markdownFromFile(**kwargs)</a></li>
<li><a href="#markdownmarkdownkwargs">markdown.Markdown([**kwargs])</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

</div>
<div id="content">
<h1 id="using-markdown-as-a-python-library">Using Markdown as a Python Library</h1>
<p>First and foremost, Python-Markdown is intended to be a python library module
used by various projects to convert Markdown syntax into HTML.</p>
<h2 id="the-basics">The Basics</h2>
<p>To use markdown as a module:</p>
<pre><code>import markdown
html = markdown.markdown(your_text_string)
</code></pre>
<h2 id="the-details">The Details</h2>
<p>Python-Markdown provides two public functions (<code>markdown.markdown</code> and 
<code>markdown.markdownFromFile</code>) both of which wrap the public class
<code>markdown.Markdown</code>. If you're processing one document at a time, the
functions will serve your needs. However, if you need to process 
multiple documents, it may be advantageous to create a single instance 
of the <code>markdown.Markdown</code> class and pass multiple documents through it.</p>
<h3 id="markdownmarkdowntext-kwargs"><code>markdown.markdown(text [, **kwargs])</code></h3>
<p>The following options are available on the <code>markdown.markdown</code> function:</p>
<ul>
<li>
<p><code>text</code> (required): The source text string.</p>
<p>Note that Python-Markdown expects <strong>Unicode</strong> as input (although
a simple ASCII string may work) and returns output as Unicode.<br />
Do not pass encoded strings to it! If your input is encoded, (e.g. as 
UTF-8), it is your responsibility to decode it.  For example:</p>
<pre><code>input_file = codecs.open("some_file.txt", mode="r", encoding="utf-8")
text = input_file.read()
html = markdown.markdown(text)
</code></pre>
<p>If you want to write the output to disk, you must encode it yourself:</p>
<pre><code>output_file = codecs.open("some_file.html", "w", 
                          encoding="utf-8", 
                          errors="xmlcharrefreplace"
)
output_file.write(html)
</code></pre>
</li>
<li>
<p><code>extensions</code>: A list of extensions.</p>
<p>Python-Markdown provides an API for third parties to write extensions to
the parser adding their own additions or changes to the syntax. A few
commonly used extensions are shipped with the markdown library. See
the <a href="extensions">extension documentation</a> for a list of available extensions.</p>
<p>The list of extensions may contain instances of extensions or stings of
extension names. If an extension name is provided as a string, the
extension must be importable as a python module either within the 
<code>markdown.extensions</code> package or on your PYTHONPATH with a name starting 
with <code>mdx_</code>, followed by the name of the extension.  Thus, 
<code>extensions=['extra']</code> will first look for the module 
<code>markdown.extensions.extra</code>, then a module named <code>mdx_extra</code>. </p>
</li>
<li>
<p><code>extension-configs</code>: A dictionary of configuration settings for extensions.</p>
<p>The dictionary must be of the following format:</p>
<pre><code>extension-configs = {'extension_name_1': 
                       [
                          ('option_1', 'value_1'),
                          ('option_2', 'value_2')
                       ],
                     'extension_name_2':
                       [
                          ('option_1', 'value_1')
                       ]
                    }
</code></pre>
<p>See the documentation specific to the extension you are using for help in 
specifying configuration settings for that extension.</p>
</li>
<li>
<p><code>output_format</code>: Format of output. </p>
<p>Supported formats are:</p>
<ul>
<li><code>"xhtml1"</code>: Outputs XHTML 1.x. <strong>Default</strong>.</li>
<li><code>"xhtml5"</code>: Outputs XHTML style tags of HTML 5</li>
<li><code>"xhtml"</code>: Outputs latest supported version of XHTML (currently XHTML 1.1).</li>
<li><code>"html4"</code>: Outputs HTML 4</li>
<li><code>"html5"</code>: Outputs HTML style tags of HTML 5</li>
<li><code>"html"</code>: Outputs latest supported version of HTML (currently HTML 4).</li>
</ul>
<p>Note that it is suggested that the more specific formats ("xhtml1",
"html5", &amp; "html4") be used as "xhtml" or "html" may change in the future
if it makes sense at that time. The values can either be lowercase or 
uppercase.</p>
</li>
<li>
<p><code>safe_mode</code>: Disallow raw html.</p>
<p>If you are using Markdown on a web system which will transform text 
provided by untrusted users, you may want to use the "safe_mode" 
option which ensures that the user's HTML tags are either replaced, 
removed or escaped. (They can still create links using Markdown syntax.)</p>
<p>The following values are accepted:</p>
<ul>
<li>
<p><code>False</code> (Default): Raw HTML is passed through unaltered.</p>
</li>
<li>
<p><code>replace</code>: Replace all HTML blocks with the text assigned to 
  <code>html_replacement_text</code> To maintain backward compatibility, setting 
  <code>safe_mode=True</code> will have the same effect as <code>safe_mode='replace'</code>. <br />
</p>
<p>To replace raw HTML with something other than the default, do:</p>
<pre><code>md = markdown.Markdown(safe_mode='replace', 
                   html_replacement_text='--RAW HTML NOT ALLOWED--')
</code></pre>
</li>
<li>
<p><code>remove</code>: All raw HTML will be completely stripped from the text with
  no warning to the author.</p>
</li>
<li>
<p><code>escape</code>: All raw HTML will be escaped and included in the document.</p>
<p>For example, the following source:</p>
<pre><code>Foo &lt;b&gt;bar&lt;/b&gt;.
</code></pre>
<p>Will result in the following HTML:</p>
<pre><code>&lt;p&gt;Foo &amp;lt;b&amp;gt;bar&amp;lt;/b&amp;gt;.&lt;/p&gt;
</code></pre>
</li>
</ul>
<p>Note that "safe_mode" does not alter the <code>enable_attributes</code> option, which 
could allow someone to inject javascript (i.e., <code onclick="alert(1)"></code>). You 
may also want to set <code>enable_attributes=False</code> when using "safe_mode".</p>
</li>
<li>
<p><code>html_replacement_text</code>: Text used when safe_mode is set to <code>replace</code>.
  Defaults to <code>[HTML_REMOVED]</code>.</p>
</li>
<li>
<p><code>tab_length</code>: Length of tabs in the source. Default: 4</p>
</li>
<li>
<p><code>enable_attributes</code>: Enable the conversion of attributes. Default: True</p>
</li>
<li>
<p><code>smart_emphasis</code>: Treat <code>_connected_words_</code> intelligently Default: True</p>
</li>
<li>
<p><code>lazy_ol</code>: Ignore number of first item of ordered lists. Default: True</p>
<p>Given the following list:</p>
<pre><code>4. Apples
5. Oranges
6. Pears
</code></pre>
<p>By default markdown will ignore the fact the the first line started 
with item number "4" and the HTML list will start with a number "1".
If <code>lazy_ol</code> is set to <code>True</code>, then markdown will output the following
HTML:</p>
<pre><code>&lt;ol&gt;
  &lt;li start="4"&gt;Apples&lt;/li&gt;
  &lt;li&gt;Oranges&lt;/li&gt;
  &lt;li&gt;Pears&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
</li>
</ul>
<h3 id="markdownmarkdownfromfilekwargs"><code>markdown.markdownFromFile(**kwargs)</code></h3>
<p>With a few exceptions, <code>markdown.markdownFromFile</code> accepts the same options as 
<code>markdown.markdown</code>. It does <strong>not</strong> accept a <code>text</code> (or Unicode) string. 
Instead, it accepts the following required options:</p>
<ul>
<li>
<p><code>input</code> (required): The source text file.</p>
<p><code>input</code> may be set to one of three options:</p>
<ul>
<li>a string which contains a path to a readable file on the file system,</li>
<li>a readable file-like object,</li>
<li>or <code>None</code> (default) which will read from <code>stdin</code>.</li>
</ul>
</li>
<li>
<p><code>output</code>: The target which output is written to.</p>
<p><code>output</code> may be set to one of three options:</p>
<ul>
<li>a string which contains a path to a writable file on the file system,</li>
<li>a writable file-like object,</li>
<li>or <code>None</code> (default) which will write to <code>stdout</code>.</li>
</ul>
</li>
<li>
<p><code>encoding</code>: The encoding of the source text file. Defaults to 
  "utf-8". The same encoding will always be used for input and output. 
  The 'xmlcharrefreplace' error handler is used when encoding the output.</p>
<p><strong>Note:</strong> This is the only place that decoding and encoding of unicode
takes place in Python-Markdown. If this rather naive solution does not
meet your specific needs, it is suggested that you write your own code
to handle your encoding/decoding needs.</p>
</li>
</ul>
<h3 id="markdownmarkdownkwargs"><code>markdown.Markdown([**kwargs])</code></h3>
<p>The same options are available when initializing the <code>markdown.Markdown</code> class
as on the <code>markdown.markdown</code> function, except that the class does <strong>not</strong>
accept a source text string on initialization. Rather, the source text string
must be passed to one of two instance methods:</p>
<ul>
<li>
<p><code>Markdown.convert(source)</code></p>
<p>The <code>source</code> text must meet the same requirements as the <code>text</code> argument
of the <code>markdown.markdown</code> function.</p>
<p>You should also use this method if you want to process multiple strings
without creating a new instance of the class for each string.</p>
<pre><code>md = markdown.Markdown()
html1 = md.convert(text1)
html2 = md.convert(text2)
</code></pre>
<p>Note that depending on which options and/or extensions are being used,
the parser may need its state reset between each call to <code>convert</code>.</p>
<pre><code>html1 = md.convert(text1)
md.reset()
html2 = md.convert(text2)
</code></pre>
<p>You can also change calls to <code>reset</code> togeather:</p>
<pre><code>html3 = md.reset().convert(text3)
</code></pre>
</li>
<li>
<p><code>Markdown.convertFile(**kwargs)</code></p>
<p>The arguments of this method are identical to the arguments of the same
name on the <code>markdown.markdownFromFile</code> function (<code>input</code>, <code>output</code>, and 
<code>encoding</code>). As with the <code>convert</code> method, this method should be used to 
process multiple files without creating a new instance of the class for 
each document. State may need to be <code>reset</code> between each call to 
<code>convertFile</code> as is the case with <code>convert</code>.</p>
</li>
</ul>
</div>
<p id="foot">&copy; 2010 Python Markdown Project<p>
</body>
</html>
